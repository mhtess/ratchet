// #### Rational Speech Act model
//
// ##### Utterances
//
// lifted-threshold model on the diffs?
//
// - `diffs > theta`  means "It's increasing more than you would expect."
// - `diffs < theta`  means "It's decreasing more than you would expect."
// - `approxEqual(diffs, 0)`  means "They're unrelated."
//
// Why not :
//
// - `diffs > 0`  means it's increasing
// - `diffs < 0`  means it's decreasing
//
// ?
// var opts = {method: "optimize", samples: 1000, steps: 1000,
//             optMethod: {adam: {stepSize: .01}}};
var opts = {method: "enumerate"};
// var opts = {method: "MCMC", kernel: "HMC", samples: 1000, burn: 500, verbose: true};
// var opts = {method: "MCMC", samples: 10000, burn: 5000, verbose: true};
// var opts = {method: "forward", samples: 1000}

var snap = function(x){
  return Math.round(x*bins)/bins;
}

var alphas = {s1: 3, s2: 1};
var utterances = ["generic_increasing", "generic_decreasing", "silence"];

var minBin = stateVals[0];
var maxBin = stateVals[stateVals.length - 1];
var nBins = stateVals.length;
var binWidth = (Math.abs(maxBin) + Math.abs(minBin)) / (nBins - 1);

var lowerThresholdBins = map(function(x){
  return x - (binWidth / 2);
}, stateVals);

var upperThresholdBins = map(function(x){
  return x + (binWidth / 2);
}, stateVals);

var lowerThresholdPrior = Infer({
  model: function() { return uniformDraw(lowerThresholdBins) }
});
var upperThresholdPrior = Infer({
  model: function() { return uniformDraw(upperThresholdBins) }
});
var utterancePrior = Infer({
  model: function() { return uniformDraw(utterances) }
});

var meaning = function(utterance, state, lowerThreshold, upperThreshold) {
   utterance === "generic_increasing" ? state > lowerThreshold :
   utterance === "generic_decreasing" ? state < upperThreshold :
  true
}

var literalListener = cache(function(utterance, lowerThreshold, upperThreshold) {
  Infer({model: function(){
    var state = sample(statePrior.b1)
    var m = meaning(utterance, state, lowerThreshold, upperThreshold);
    condition(m)
    return state
  }})
})

var speaker1 = cache(function(state, lowerThreshold, upperThreshold) {
  Infer({model: function(){
    var utterance = sample(utterancePrior)
    var L0 = literalListener(utterance, lowerThreshold, upperThreshold)
    factor( alphas.s1 * L0.score(state) )
    return utterance
  }})
})

var listener1 = cache(function(utterance) {
  Infer({model: function(){
    var state = sample(statePrior.b1);
    var lowerThreshold = 0;//sample(lowerThresholdPrior);
    var upperThreshold = 0;//sample(upperThresholdPrior);
    var S1 = speaker1(state, lowerThreshold, upperThreshold)
    observe(S1, utterance)
    return state
  }})
})


var observer = cache(function(data, beliefs){
  return Infer(opts, function(){
    var betas = Vector([
      sample(beliefs.b0), sample(beliefs.b1)
    ]);
    mapData({data}, function(d){
        var predicted_y = T.get(betas, 0) + T.get(betas, 1)*d.x;
        observe(Gaussian({mu: predicted_y, sigma: sigma_y}), d.y);
    })
    return T.get(betas, 1);
  })
});

var generateData = function(){
  return repeat(20, function(){
    var x = uniform(0,1);
    var y = 1 - x;
    return {x, y}
  });
};
// var post = observer(data)
// // post.support().length
// // viz(observer(data))

// viz(post)
var gen0 = function(data){
  Infer({model: function(){
    var speakerBeliefs = observer(data, statePrior);
    var slope = sample(speakerBeliefs);
    var utterance = sample(utterancePrior);
    var L1 = listener1(utterance);
    factor(alphas.s2 * L1.score(slope));
    return utterance
  }})
}

var oneGeneration = function(uttDist, data){
  Infer({model: function(){

    var utt = sample(uttDist);
    var beliefsAfterLanguage = listener1(utt); // currently, only on b1
    var beliefsAfterData = observer(data,
      {b0: statePrior.b0, b1: beliefsAfterLanguage}
    );

    var slope = sample(beliefsAfterData);
    var utterance = sample(utterancePrior);
    var L1 = listener1(utterance);
    factor(alphas.s2 * L1.score(slope));
    return utterance

  }})
}

var nChains = 3;

var runChain = function(n, lang){
  var data = generateData();
  var uttDist = oneGeneration(lang, data);
  var nGen = (nChains - n)

  display("gen-" +  nGen + " genDecreasing " +
   Math.exp(uttDist.score("generic_decreasing")))
  if (n == 0){
    return uttDist;
  } else {
    return runChain(n - 1, uttDist);
  }
}

var g0 = gen0(generateData());

runChain(nChains, g0);
// speaker(data)
